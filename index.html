<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>drag-to-inside</title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }
    </style>
  </head>
  <body>
    <script src="pixi.js-master/bin/pixi.min.js"></script>
    <script>
    //Aliases
    var Container = PIXI.Container,
      autoDetectRenderer = PIXI.autoDetectRenderer,
      loader = PIXI.loader,
      resources = PIXI.loader.resources,
      TextureCache = PIXI.utils.TextureCache,
      Texture = PIXI.Texture,
      Sprite = PIXI.Sprite,
      Graphics = PIXI.Graphics;

    //Create a Pixi stage and renderer and add the renderer.view to the DOM
    var stage = new Container(),
      renderer = autoDetectRenderer(768, 768);
    renderer.backgroundColor = 0x333333;
    document.body.appendChild(renderer.view);

    loader
      .add("images/cat.png")
      .load(setup);

    var state, message;
    var func1_box, func1_input1, func1_output1, func1_grip, func1_set;
    var func2_box, func2_input1, func2_output1, func2_grip, func2_set;

    function setup() {
      func2_box = new Graphics();
      func2_box.beginFill(0xe3ac9a);
      func2_box.drawRect(0, 0, 140, 260);
      func2_box.endFill();
      func2_box.x = 0;
      func2_box.y = 0;

      func2_input1 = new Graphics();
      func2_input1.beginFill(0xace39a);
      func2_input1.drawRect(0, 0, 100, 100);
      func2_input1.endFill();
      func2_input1.position.x = 20;
      func2_input1.position.y = 20;

      func2_output1 = new Graphics();
      func2_output1.beginFill(0x9ad1e3);
      func2_output1.drawRect(0, 0, 100, 100);
      func2_output1.endFill();
      func2_output1.position.x = 20;
      func2_output1.position.y = 140;

      func2_grip = new Graphics();
      func2_grip.beginFill(0x000000);
      func2_grip.drawRect(0, 0, 20, 20);
      func2_grip.endFill();
      func2_grip.position.x = 0;
      func2_grip.position.y = 0;

      func2_set = new Container();
      func2_set.addChild(func2_box);
      func2_set.addChild(func2_input1);
      func2_set.addChild(func2_output1);
      func2_set.addChild(func2_grip);

      func2_set.interactive = true;
      func2_set.buttonMode = true;
      func2_set.hitArea = new PIXI.Rectangle(0, 0, 20, 20);

      func2_set
        .on('mousedown', onDragStart)
        .on('touchstart', onDragStart)
        .on('mouseup', onDragEnd)
        .on('mouseupoutside', onDragEnd)
        .on('touchend', onDragEnd)
        .on('touchendoutside', onDragEnd)
        .on('mousemove', onDragMove)
        .on('touchmove', onDragMove);

      func2_set.position.x = 200;
      func2_set.position.y = 200;

      stage.addChild(func2_set);

      func1_box = new Graphics();
      func1_box.beginFill(0xc29de0);
      func1_box.drawRect(0, 0, 140, 260);
      func1_box.endFill();
      func1_box.x = 0;
      func1_box.y = 0;

      func1_input1 = new Graphics();
      func1_input1.beginFill(0xbbe09d);
      func1_input1.drawRect(0, 0, 100, 100);
      func1_input1.endFill();
      func1_input1.position.x = 20;
      func1_input1.position.y = 20;

      func1_output1 = new Graphics();
      func1_output1.beginFill(0x9ddde0);
      func1_output1.drawRect(0, 0, 100, 100);
      func1_output1.endFill();
      func1_output1.position.x = 20;
      func1_output1.position.y = 140;

      func1_grip = new Graphics();
      func1_grip.beginFill(0x000000);
      func1_grip.drawRect(0, 0, 20, 20);
      func1_grip.endFill();
      func1_grip.position.x = 0;
      func1_grip.position.y = 0;

      func1_set = new Container();
      func1_set.addChild(func1_box);
      func1_set.addChild(func1_input1);
      func1_set.addChild(func1_output1);
      func1_set.addChild(func1_grip);

      func1_set.interactive = true;
      func1_set.buttonMode = true;
      func1_set.hitArea = new PIXI.Rectangle(0, 0, 20, 20);

      func1_set
        .on('mousedown', onDragStart)
        .on('touchstart', onDragStart)
        .on('mouseup', onDragEnd)
        .on('mouseupoutside', onDragEnd)
        .on('touchend', onDragEnd)
        .on('touchendoutside', onDragEnd)
        .on('mousemove', onDragMove)
        .on('touchmove', onDragMove);

      func1_set.position.x = 500;
      func1_set.position.y = 200;

      stage.addChild(func1_set);

      message = new PIXI.Text(
        "No collision...",
        {font: "18px", fill: "white"}
      );
      message.position.set(8, 8);
      stage.addChild(message);

      state = play;

      gameLoop();
    }


    function gameLoop(){

      //Loop this function 60 times per second
      requestAnimationFrame(gameLoop);

      //Update the current game state
      state();

      //Render the stage
      renderer.render(stage);
    }

    function play() {
      //check for a collision between the cat and the box
    };


    //The `hitTestRectangle` function
    function hitTestInput(r1, r2) {
      //Define the variables we'll need to calculate
      var hit, combinedHalfWidths, combinedHalfHeights, vx, vy;
      //hit will determine whether there's a collision
      hit = false;
      //Find the center points of each sprite
      r1.centerX = r1.worldTransform.tx + r1.width / 2;
      r1.centerY = r1.worldTransform.ty + r1.height / 2;
      r2.centerX = r2.worldTransform.tx + r2.width / 2;
      r2.centerY = r2.worldTransform.ty + r2.height / 2;
      //Find the half-widths and half-heights of each sprite
      r1.halfWidth = r1.width / 2;
      r1.halfHeight = r1.height / 2;
      r2.halfWidth = r2.width / 2;
      r2.halfHeight = r2.height / 2;
      //Calculate the distance vector between the sprites
      vx = r1.centerX - r2.centerX;
      vy = r1.centerY - r2.centerY;
      //Figure out the combined half-widths and half-heights
      combinedHalfWidths = r1.halfWidth + r2.halfWidth;
      combinedHalfHeights = r1.halfHeight + r2.halfHeight;
      //Check for a collision on the x axis
      if (Math.abs(vx) < combinedHalfWidths) {
        //A collision might be occuring. Check for a collision on the y axis
        if (Math.abs(vy) < combinedHalfHeights) {
          //There's definitely a collision happening
          hit = true;
        } else {
          //There's no collision on the y axis
          hit = false;
        }
      } else {
        //There's no collision on the x axis
        hit = false;
      }
      //`hit` will be either `true` or `false`
      return hit;
    };



    function onDragStart(event)
    {
      // store a reference to the data
      // the reason for this is because of multitouch
      // we want to track the movement of this particular touch
      this.data = event.data;
      this.alpha = 0.5;
      this.dragging = true;
    }

    function onDragEnd()
    {
      this.alpha = 1;

      this.dragging = false;

      // set the interaction data to null
      this.data = null;

      if(this != func1_set) {
        checkHit(func1_set, this);
      } else if (this != func2_set) {
        checkHit(func2_set, this);
      }
    }

    function onDragMove()
    {
      if (this.dragging)
      {
        var newPosition = this.data.getLocalPosition(this.parent);
        this.position.x = newPosition.x;
        this.position.y = newPosition.y;
      }
    }
    
    function checkHit(target_set, moving_set) {
      if (hitTestInput(target_set.getChildAt(1), moving_set.getChildAt(3))) {
        message.text = "input hit!";
        target_set.getChildAt(0).width = 180;
        target_set.getChildAt(0).height = 460;
        target_set.getChildAt(1).width = 100;
        target_set.getChildAt(1).height = 100;
        moving_set.position.x = target_set.getChildAt(1).worldTransform.tx;
        moving_set.position.y = target_set.getChildAt(1).worldTransform.ty;
        target_set.getChildAt(2).position.y = target_set.getChildAt(1).y + 280;
        target_set.getChildAt(2).width = 140;
        target_set.getChildAt(2).height = 140;
      } else if (hitTestInput(target_set.getChildAt(2), moving_set.getChildAt(3))) {
        message.text = "output hit!";
        target_set.getChildAt(0).width = 180;
        target_set.getChildAt(0).height = 460;
        target_set.getChildAt(1).width = 140;
        target_set.getChildAt(1).height = 140;
        target_set.getChildAt(2).position.y = target_set.getChildAt(1).y + 160;
        moving_set.position.x = target_set.getChildAt(1).worldTransform.tx;
        moving_set.position.y = target_set.getChildAt(1).worldTransform.ty + 160;
      } else {
        message.text = "No collision...";
        target_set.getChildAt(0).width = 140;
        target_set.getChildAt(0).height = 260;
        target_set.getChildAt(1).width = 100;
        target_set.getChildAt(1).height = 100;
        target_set.getChildAt(2).position.y = target_set.getChildAt(1).y + 120;
        target_set.getChildAt(2).width = 100;
        target_set.getChildAt(2).height = 100;
      }
    }
    </script>
  </body>
</html>
