<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>drag-to-inside</title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }
    </style>
  </head>
  <body>
    <script src="./libs/pixi.min.js"></script>
    <script>
    //Aliases
    var Container = PIXI.Container,
      autoDetectRenderer = PIXI.autoDetectRenderer,
      loader = PIXI.loader,
      resources = PIXI.loader.resources,
      TextureCache = PIXI.utils.TextureCache,
      Texture = PIXI.Texture,
      Sprite = PIXI.Sprite,
      Graphics = PIXI.Graphics;
    //Create a Pixi stage and renderer and add the renderer.view to the DOM
    var stage = new Container(),
      renderer = autoDetectRenderer(768, 768);
    renderer.backgroundColor = 0x333333;
    document.body.appendChild(renderer.view);
    loader
      .add("images/cat.png")
      .add("images/trash_can_closed.png")
      .load(setup);
    var state, message, trashcan, cat;
    var activeBlocks, totalBlocks;
    var blockIndex;
    var target_set, moving_set;
    activeBlocks = 0;
    totalBlocks = 0;
    function setup() {
      trashcan = new Sprite(resources["images/trash_can_closed.png"].texture);
      trashcan.x = 680;
      trashcan.y = 640;
      stage.addChild(trashcan);
      cat = new Sprite(resources["images/cat.png"].texture);
      cat.x = 560;
      cat.y = 660;
      stage.addChild(cat);
      cat.interactive = true;
      cat.buttonMode = true;
      cat
        .on('click', function() {
          addBlock();
          totalBlocks++;
          activeBlocks++;
          console.log(activeBlocks);
        });
      message = new PIXI.Text(
        "No collision...",
        {font: "18px", fill: "white"}
      );
      message.position.set(8, 8);
      stage.addChild(message);
      state = play;
      gameLoop();
    }
    function gameLoop() {
      //Loop this function 60 times per second
      requestAnimationFrame(gameLoop);
      //Update the current state
      state();
      //Render the stage
      renderer.render(stage);
    }
    function play() {
    };
    function onDragStart(event) {
      // store a reference to the data
      // the reason for this is because of multitouch
      // we want to track the movement of this particular touch
      this.data = event.data;
      this.alpha = 0.5;
      this.dragging = true;
      this.scale.x *= 1.1;
      this.scale.y *= 1.1;
      this.dragPoint = event.data.getLocalPosition(this.parent);
      this.dragPoint.x -= this.position.x;
      this.dragPoint.y -= this.position.y;
    }
    function onDragEnd() {
      this.alpha = 1;
      this.dragging = false;
      // set the interaction data to null
      this.data = null;
      this.scale.x /= 1.1;
      this.scale.y /= 1.1;
      for(blockIndex = 1; blockIndex <= activeBlocks; blockIndex++) {
        // run hitTest without itself
        if(blockIndex != stage.getChildIndex(this)-2) {
          target_set = stage.getChildAt(blockIndex+2);
          moving_set = this;
          if(hitTest(target_set.getChildAt(1), moving_set.getChildAt(3))) {
            message.text = "input hit! / targetBlockNumber : " + blockIndex + " & movingBlockNumber : " + (stage.getChildIndex(this)-2);
            target_set.getChildAt(0).width = 180;
            target_set.getChildAt(0).height = 460;
            target_set.getChildAt(1).width = 100;
            target_set.getChildAt(1).height = 100;
            moving_set.position.x = target_set.getChildAt(1).worldTransform.tx;
            moving_set.position.y = target_set.getChildAt(1).worldTransform.ty;
            target_set.getChildAt(2).position.y = target_set.getChildAt(1).y + 280;
            target_set.getChildAt(2).width = 140;
            target_set.getChildAt(2).height = 140;
            break;
          } else if(hitTest(target_set.getChildAt(2), moving_set.getChildAt(3))) {
            message.text = "output hit! / targetBlockNumber : " + blockIndex + " & movingBlockNumber : " + (stage.getChildIndex(this)-2);
            target_set.getChildAt(0).width = 180;
            target_set.getChildAt(0).height = 460;
            target_set.getChildAt(1).width = 140;
            target_set.getChildAt(1).height = 140;
            target_set.getChildAt(2).position.y = target_set.getChildAt(1).y + 160;
            moving_set.position.x = target_set.getChildAt(1).worldTransform.tx;
            moving_set.position.y = target_set.getChildAt(1).worldTransform.ty + 160;
            break;
          } else {
            message.text = "No collision...";
            target_set.getChildAt(0).width = 140;
            target_set.getChildAt(0).height = 260;
            target_set.getChildAt(1).width = 100;
            target_set.getChildAt(1).height = 100;
            target_set.getChildAt(2).position.y = target_set.getChildAt(1).y + 120;
            target_set.getChildAt(2).width = 100;
            target_set.getChildAt(2).height = 100;
          }
        }
      }
      if(hitTest(this, trashcan)) {
        stage.removeChild(this);
        activeBlocks--;
      }
    }
    function onDragMove() {
      if(this.dragging) {
        var newPosition = this.data.getLocalPosition(this.parent);
        this.position.x = newPosition.x - this.dragPoint.x;
        this.position.y = newPosition.y - this.dragPoint.y;
        for(blockIndex = 1; blockIndex <= activeBlocks; blockIndex++) {
          // run hitTest without itself
          if(blockIndex != stage.getChildIndex(this)-2) {
            target_set = stage.getChildAt(blockIndex+2);
            moving_set = this;
            if(hitTest(moving_set.getChildAt(1), target_set.getChildAt(3))) {
              target_set.position.x = newPosition.x - moving_set.dragPoint.x + 20;
              target_set.position.y = newPosition.y - moving_set.dragPoint.y + 20;
              break;
            } else if(hitTest(moving_set.getChildAt(2), target_set.getChildAt(3))) {
              target_set.position.x = newPosition.x - moving_set.dragPoint.x + 20;
              target_set.position.y = newPosition.y - moving_set.dragPoint.y + 180;
              break;
            }
          }
        }
      }
    }
    function addBlock() {
      var block, input1, input2, grip, set;
      block = new Graphics();
      block.beginFill(0xec686d);
      block.drawRect(0, 0, 140, 260);
      block.endFill();
      block.x = 0;
      block.y = 0;
      input1 = new Graphics();
      input1.beginFill(0xffffff);
      input1.drawRect(0, 0, 100, 100);
      input1.endFill();
      input1.position.x = 20;
      input1.position.y = 20;
      input2 = new Graphics();
      input2.beginFill(0xffffff);
      input2.drawRect(0, 0, 100, 100);
      input2.endFill();
      input2.position.x = 20;
      input2.position.y = 140;
      grip = new Graphics();
      grip.beginFill(0xe63339);
      grip.drawRect(0, 0, 20, 20);
      grip.endFill();
      grip.position.x = 0;
      grip.position.y = 0;
      set = new Container();
      set.addChild(block);
      set.addChild(input1);
      set.addChild(input2);
      set.addChild(grip);
      set.interactive = true;
      set.buttonMode = true;
      set.hitArea = new PIXI.Rectangle(0, 0, 20, 20);
      set
        .on('mousedown', onDragStart)
        .on('touchstart', onDragStart)
        .on('mouseup', onDragEnd)
        .on('mouseupoutside', onDragEnd)
        .on('touchend', onDragEnd)
        .on('touchendoutside', onDragEnd)
        .on('mousemove', onDragMove)
        .on('touchmove', onDragMove);
      set.position.x = 50;
      set.position.y = 500;
      stage.addChild(set);
    }
    function hitTest(r1, r2) {
      //Define the variables we'll need to calculate
      var hit, combinedHalfWidths, combinedHalfHeights, vx, vy;
      //hit will determine whether there's a collision
      hit = false;
      //Find the center points of each graphics
      r1.centerX = r1.worldTransform.tx + r1.width / 2;
      r1.centerY = r1.worldTransform.ty + r1.height / 2;
      r2.centerX = r2.worldTransform.tx + r2.width / 2;
      r2.centerY = r2.worldTransform.ty + r2.height / 2;
      //Find the half-widths and half-heights of each graphics
      r1.halfWidth = r1.width / 2;
      r1.halfHeight = r1.height / 2;
      r2.halfWidth = r2.width / 2;
      r2.halfHeight = r2.height / 2;
      //Calculate the distance vector between the graphics
      vx = r1.centerX - r2.centerX;
      vy = r1.centerY - r2.centerY;
      //Figure out the combined half-widths and half-heights
      combinedHalfWidths = r1.halfWidth + r2.halfWidth;
      combinedHalfHeights = r1.halfHeight + r2.halfHeight;
      //Check for a collision on the x axis
      if (Math.abs(vx) < combinedHalfWidths) {
        //A collision might be occuring. Check for a collision on the y axis
        if (Math.abs(vy) < combinedHalfHeights) {
          //There's definitely a collision happening
          hit = true;
        } else {
          //There's no collision on the y axis
          hit = false;
        }
      } else {
        //There's no collision on the x axis
        hit = false;
      }
      //`hit` will be either `true` or `false`
      return hit;
    };
    </script>
  </body>
</html>
