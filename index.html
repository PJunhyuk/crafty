<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>drag-to-inside</title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }
    </style>
  </head>
  <body>
    <script src="./libs/pixi.min.js"></script>
    <script src="./libs/pixi-display.js"></script>
    <script>
    //Aliases
    var Container = PIXI.Container,
      autoDetectRenderer = PIXI.autoDetectRenderer,
      loader = PIXI.loader,
      resources = PIXI.loader.resources,
      TextureCache = PIXI.utils.TextureCache,
      Texture = PIXI.Texture,
      Sprite = PIXI.Sprite,
      Graphics = PIXI.Graphics;

    //Create a Pixi stage and renderer and add the renderer.view to the DOM
    var stage = new Container(),
      renderer = autoDetectRenderer(768, 768);
    renderer.backgroundColor = 0x333333;
    document.body.appendChild(renderer.view);

    //Load images
    loader
      .add("images/trash_can_closed.png")
      .add("images/add_button.png")
      .load(setup);

    //Declare global variables
    var state, message, trashcan, cat, noticeBoard;
    var blockIndex;
    var target_set, moving_set;
    //activeBlocks : How many blocks in stage
    var activeBlocks = 0;
    //revisionConst : How many Child before blocks
    var revisionConst = 3;

    //Declare DisplayGroups - (depth, sort status)
    stage.displayList = new PIXI.DisplayList();
    var defaultLayer = new PIXI.DisplayGroup(0, true);
    var insideLayer1 = new PIXI.DisplayGroup(1, false);
    var dragLayer = new PIXI.DisplayGroup(2, false);


    //First running function
    function setup() {
      //Initialize trashcan
      trashcan = new Sprite(resources["images/trash_can_closed.png"].texture);
      trashcan.x = 680;
      trashcan.y = 640;
      stage.addChild(trashcan);

      //Initialize addButton
      addButton = new Sprite(resources["images/add_button.png"].texture);
      addButton.x = 590;
      addButton.y = 641;
      stage.addChild(addButton);
      addButton.interactive = true;
      addButton.buttonMode = true;
      addButton
        .on('click', function() {
          addBlock();
        });

      //Initialize message
      message = new PIXI.Text(
        "No collision...",
        {font: "18px", fill: "white"}
      );
      message.position.set(8, 8);
      stage.addChild(message);

      //Initialize noticeBoard
      noticeBoard = new PIXI.Text(
        "noticeBoard",
        {font: "18px", fill: "white"}
      );
      noticeBoard.position.set(8, 38);
      stage.addChild(noticeBoard);

      //Set state to play, and run gameLoop
      state = play;
      gameLoop();
    }


    function gameLoop() {
      //Loop this function 60 times per second
      requestAnimationFrame(gameLoop);
      //Update the current state
      state();
      //Render the stage
      renderer.render(stage);
    }


    function play() {
    };


    function onDragStart(event) {
      // store a reference to the data
      // the reason for this is because of multitouch
      // we want to track the movement of this particular touch
      if(!this.dragging) {
        this.data = event.data;
        this.dragging = true;
        this.alpha = 0.5;
        this.dragging = true;
        this.scale.x *= 1.1;
        this.scale.y *= 1.1;
        this.dragPoint = event.data.getLocalPosition(this.parent);
        this.dragPoint.x -= this.position.x;
        this.dragPoint.y -= this.position.y;

        //Dragging object : highest depth
        this.oldGroup = this.displayGroup;
        this.displayGroup = dragLayer;

        //Print blockIndex of dragging block
        console.log(stage.getChildIndex(this) - revisionConst);
      }
    }


    function onDragMove() {
      if(this.dragging) {
        var newPosition = this.data.getLocalPosition(this.parent);
        this.position.x = newPosition.x - this.dragPoint.x;
        this.position.y = newPosition.y - this.dragPoint.y;

        //If dragging block has child, drag with it
        for(blockIndex = 1; blockIndex <= activeBlocks; blockIndex++) {
          target_set = stage.getChildAt(blockIndex+revisionConst);
          moving_set = this;
          if(moving_set.indexOfChild != 0) {
            if(hitTest(moving_set.getChildAt(1), target_set.getChildAt(3))) {
              target_set.position.x = newPosition.x - moving_set.dragPoint.x + 20;
              target_set.position.y = newPosition.y - moving_set.dragPoint.y + 20;
              break;
            } else if(hitTest(moving_set.getChildAt(2), target_set.getChildAt(3))) {
              target_set.position.x = newPosition.x - moving_set.dragPoint.x + 20;
              target_set.position.y = newPosition.y - moving_set.dragPoint.y + 180;
              break;
            }
          }
        }
      }
    }


    function onDragEnd() {
      this.alpha = 1;
      this.dragging = false;
      //Set the interaction data to null
      this.data = null;
      this.scale.x /= 1.1;
      this.scale.y /= 1.1;
      //Set displayGroup of dragging object to defaultLayer
      this.displayGroup = defaultLayer;

      //Check Hit, Change its size, and Set indexOfParent & indexOfChild
      for(blockIndex = 1; blockIndex <= activeBlocks; blockIndex++) {
        target_set = stage.getChildAt(blockIndex+revisionConst);
        moving_set = this;
        if(hitTest(target_set.getChildAt(1), moving_set.getChildAt(3))) {
          message.text = "input hit! / targetBlockNumber : " + blockIndex + " & movingBlockNumber : " + (stage.getChildIndex(this)-revisionConst);
          target_set.getChildAt(0).width = 180;
          target_set.getChildAt(0).height = 460;
          target_set.getChildAt(1).width = 100;
          target_set.getChildAt(1).height = 100;
          moving_set.position.x = target_set.getChildAt(1).worldTransform.tx;
          moving_set.position.y = target_set.getChildAt(1).worldTransform.ty;
          target_set.getChildAt(2).position.y = target_set.getChildAt(1).y + 280;
          target_set.getChildAt(2).width = 140;
          target_set.getChildAt(2).height = 140;
          //If dragging block had other parent, initialize it
          if(moving_set.indexOfParent != 0 && moving_set.indexOfParent != blockIndex) {
            stage.getChildAt(moving_set.indexOfParent + revisionConst).getChildAt(0).width = 140;
            stage.getChildAt(moving_set.indexOfParent + revisionConst).getChildAt(0).height = 260;
            stage.getChildAt(moving_set.indexOfParent + revisionConst).getChildAt(1).width = 100;
            stage.getChildAt(moving_set.indexOfParent + revisionConst).getChildAt(1).height = 100;
            stage.getChildAt(moving_set.indexOfParent + revisionConst).getChildAt(2).position.y = stage.getChildAt(moving_set.indexOfParent + revisionConst).getChildAt(1).y + 120;
            stage.getChildAt(moving_set.indexOfParent + revisionConst).getChildAt(2).width = 100;
            stage.getChildAt(moving_set.indexOfParent + revisionConst).getChildAt(2).height = 100;
            stage.getChildAt(moving_set.indexOfParent + revisionConst).indexOfChild = 0;
          }
          //Change displayGroup of Child block
          moving_set.displayGroup = insideLayer1;
          //Set indexOfChild & indexOfParent
          target_set.indexOfChild = stage.getChildIndex(moving_set)-revisionConst;
          moving_set.indexOfParent = blockIndex;
          break;
        } else if(hitTest(target_set.getChildAt(2), moving_set.getChildAt(3))) {
          message.text = "output hit! / targetBlockNumber : " + blockIndex + " & movingBlockNumber : " + (stage.getChildIndex(this)-revisionConst);
          target_set.getChildAt(0).width = 180;
          target_set.getChildAt(0).height = 460;
          target_set.getChildAt(1).width = 140;
          target_set.getChildAt(1).height = 140;
          target_set.getChildAt(2).position.y = target_set.getChildAt(1).y + 160;
          moving_set.position.x = target_set.getChildAt(1).worldTransform.tx;
          moving_set.position.y = target_set.getChildAt(1).worldTransform.ty + 160;
          //If dragging block had other parent, initialize it
          if(moving_set.indexOfParent != 0  && moving_set.indexOfParent != blockIndex) {
            stage.getChildAt(moving_set.indexOfParent + revisionConst).getChildAt(0).width = 140;
            stage.getChildAt(moving_set.indexOfParent + revisionConst).getChildAt(0).height = 260;
            stage.getChildAt(moving_set.indexOfParent + revisionConst).getChildAt(1).width = 100;
            stage.getChildAt(moving_set.indexOfParent + revisionConst).getChildAt(1).height = 100;
            stage.getChildAt(moving_set.indexOfParent + revisionConst).getChildAt(2).position.y = stage.getChildAt(moving_set.indexOfParent + revisionConst).getChildAt(1).y + 120;
            stage.getChildAt(moving_set.indexOfParent + revisionConst).getChildAt(2).width = 100;
            stage.getChildAt(moving_set.indexOfParent + revisionConst).getChildAt(2).height = 100;
            stage.getChildAt(moving_set.indexOfParent + revisionConst).indexOfChild = 0;
          }
          //Change displayGroup of Child block
          moving_set.displayGroup = insideLayer1;
          //Set indexOfChild & indexOfParent
          target_set.indexOfChild = stage.getChildIndex(moving_set)-revisionConst;
          moving_set.indexOfParent = blockIndex;
          break;
        }

        //If there are no hit with dragging block
        if(blockIndex == activeBlocks) {
          message.text = "No NEW collision...";
          //Initialize dragging block's parent
          if(moving_set.indexOfParent != 0) {
            stage.getChildAt(moving_set.indexOfParent + revisionConst).getChildAt(0).width = 140;
            stage.getChildAt(moving_set.indexOfParent + revisionConst).getChildAt(0).height = 260;
            stage.getChildAt(moving_set.indexOfParent + revisionConst).getChildAt(1).width = 100;
            stage.getChildAt(moving_set.indexOfParent + revisionConst).getChildAt(1).height = 100;
            stage.getChildAt(moving_set.indexOfParent + revisionConst).getChildAt(2).position.y = stage.getChildAt(moving_set.indexOfParent + revisionConst).getChildAt(1).y + 120;
            stage.getChildAt(moving_set.indexOfParent + revisionConst).getChildAt(2).width = 100;
            stage.getChildAt(moving_set.indexOfParent + revisionConst).getChildAt(2).height = 100;
            //Initialize indexOfChild & indexOfParent
            stage.getChildAt(moving_set.indexOfParent + revisionConst).indexOfChild = 0;
            moving_set.indexOfParent = 0;
          }
        }
      }

      //Check hit with trash
      if(hitTest(this, trashcan)) {
        stage.removeChild(this);
        activeBlocks--;
      }

      //Update noticeBoard
      checkBoard();
    }


    //Update noticeBoard
    function checkBoard() {
      if(activeBlocks == 0) {
        noticeBoard.text = "No blocks";
      } else {
        noticeBoard.text = "";
        for(blockIndex = 1; blockIndex <= activeBlocks; blockIndex++) {
          //If that block has parent, skip
          if(stage.getChildAt(blockIndex+revisionConst).indexOfParent == 0) {
            noticeBoard.text += blockIndex;
            if(stage.getChildAt(blockIndex+revisionConst).indexOfChild != 0) {
              //If that block has child, write with it
              noticeBoard.text += ">" + stage.getChildAt(blockIndex+revisionConst).indexOfChild;
            }
            noticeBoard.text += "   ";
          }
        }
      }
    }


    //Add block when click addButton
    function addBlock() {
      var block, input1, input2, grip, set;

      //Initialize border of block
      block = new Graphics();
      block.beginFill(0xec686d);
      block.drawRect(0, 0, 140, 260);
      block.endFill();
      block.x = 0;
      block.y = 0;

      //Initialize input1
      input1 = new Graphics();
      input1.beginFill(0xffffff);
      input1.drawRect(0, 0, 100, 100);
      input1.endFill();
      input1.position.x = 20;
      input1.position.y = 20;

      //Initialize input2
      input2 = new Graphics();
      input2.beginFill(0xffffff);
      input2.drawRect(0, 0, 100, 100);
      input2.endFill();
      input2.position.x = 20;
      input2.position.y = 140;

      //Initialize grip : we can grip it and drag block
      grip = new Graphics();
      grip.beginFill(0xe63339);
      grip.drawRect(0, 0, 20, 20);
      grip.endFill();
      grip.position.x = 0;
      grip.position.y = 0;

      //Initialize container of block elements
      set = new Container();
      set.addChild(block);
      set.addChild(input1);
      set.addChild(input2);
      set.addChild(grip);
      set.interactive = true;
      set.buttonMode = true;
      //hitArea of set == grip
      set.hitArea = new PIXI.Rectangle(0, 0, 20, 20);
      set
        .on('mousedown', onDragStart)
        .on('touchstart', onDragStart)
        .on('mouseup', onDragEnd)
        .on('mouseupoutside', onDragEnd)
        .on('touchend', onDragEnd)
        .on('touchendoutside', onDragEnd)
        .on('mousemove', onDragMove)
        .on('touchmove', onDragMove);
      set.position.x = 50;
      set.position.y = 500;
      set.displayGroup = defaultLayer;
      //Initialize index values
      set.indexOfChild = 0;
      set.indexOfParent = 0;

      //Add 1 at activeBlocks value
      activeBlocks++;

      stage.addChild(set);

      checkBoard();
    }


    //Check hit with two elements
    function hitTest(r1, r2) {
      //Define the variables we'll need to calculate
      var hit, combinedHalfWidths, combinedHalfHeights, vx, vy;
      //hit will determine whether there's a collision
      hit = false;
      //Find the center points of each graphics
      r1.centerX = r1.worldTransform.tx + r1.width / 2;
      r1.centerY = r1.worldTransform.ty + r1.height / 2;
      r2.centerX = r2.worldTransform.tx + r2.width / 2;
      r2.centerY = r2.worldTransform.ty + r2.height / 2;
      //Find the half-widths and half-heights of each graphics
      r1.halfWidth = r1.width / 2;
      r1.halfHeight = r1.height / 2;
      r2.halfWidth = r2.width / 2;
      r2.halfHeight = r2.height / 2;
      //Calculate the distance vector between the graphics
      vx = r1.centerX - r2.centerX;
      vy = r1.centerY - r2.centerY;
      //Figure out the combined half-widths and half-heights
      combinedHalfWidths = r1.halfWidth + r2.halfWidth;
      combinedHalfHeights = r1.halfHeight + r2.halfHeight;
      //Check for a collision on the x axis
      if (Math.abs(vx) < combinedHalfWidths) {
        //A collision might be occuring. Check for a collision on the y axis
        if (Math.abs(vy) < combinedHalfHeights) {
          //There's definitely a collision happening
          hit = true;
        } else {
          //There's no collision on the y axis
          hit = false;
        }
      } else {
        //There's no collision on the x axis
        hit = false;
      }
      //`hit` will be either `true` or `false`
      return hit;
    };
    </script>
  </body>
</html>
